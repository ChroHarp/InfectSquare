<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>感染方塊模擬器 (Bootstrap Percolation)</title>
    
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 引入 React 和 ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 引入 Babel (用於解析 JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        .animate-pulse-once {
            animation: pulse-orange 0.5s ease-out;
        }
        @keyframes pulse-orange {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(249, 115, 22, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(249, 115, 22, 0); }
        }
        /* 隱藏數字輸入框的上下箭頭 (Chrome, Safari, Edge, Opera) */
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        /* Firefox */
        input[type=number] {
            -moz-appearance: textfield;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- 圖示元件 (取代 lucide-react) ---
        const IconGrid = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/></svg>
        );
        const IconPlay = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"/></svg>
        );
        const IconPause = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="4" height="16" x="6" y="4"/><rect width="4" height="16" x="14" y="4"/></svg>
        );
        const IconStepForward = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="19" x2="19" y1="5" y2="19"/><polygon points="5 4 15 12 5 20 5 4"/></svg>
        );
        const IconRotateCcw = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        );
        const IconMousePointer2 = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m12 19-2.96-7.22A2 2 0 0 0 8.19 10.96L1 8l22 5-9 2Z"/></svg>
        );
        const IconPlus = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M5 12h14"/><path d="M12 5v14"/></svg>
        );
        const IconInfo = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
        );

        // --- 主應用程式 ---
        const App = () => {
            // --- 狀態變數 ---
            const [gridType, setGridType] = useState('rect'); // 'rect' | 'cross' | 'gen-cross'
            
            // 網格整體大小
            const [rows, setRows] = useState(10);
            const [cols, setCols] = useState(10);
            
            // 十字形/廣義十字形的角落切除設定
            const [uniformCorner, setUniformCorner] = useState({ w: 3, h: 3 });
            const [corners, setCorners] = useState({
                tl: { w: 2, h: 2 },
                tr: { w: 3, h: 2 },
                bl: { w: 2, h: 3 },
                br: { w: 1, h: 1 },
            });

            const [grid, setGrid] = useState([]);
            const [round, setRound] = useState(0);
            const [isRunning, setIsRunning] = useState(false);
            const [initialCount, setInitialCount] = useState(0);
            const [currentInfectedCount, setCurrentInfectedCount] = useState(0);
            const [totalValidCells, setTotalValidCells] = useState(0);
            const [simulationStatus, setSimulationStatus] = useState('idle'); // 'idle' | 'running' | 'completed' | 'stalled'

            const timerRef = useRef(null);

            // --- 初始化與網格生成 ---

            // 檢查座標是否在被挖空的區域內
            const isVoid = (r, c, R, C, currentCorners) => {
                // 左上
                if (r < currentCorners.tl.h && c < currentCorners.tl.w) return true;
                // 右上
                if (r < currentCorners.tr.h && c >= C - currentCorners.tr.w) return true;
                // 左下
                if (r >= R - currentCorners.bl.h && c < currentCorners.bl.w) return true;
                // 右下
                if (r >= R - currentCorners.br.h && c >= C - currentCorners.br.w) return true;
                
                return false;
            };

            const generateGrid = useCallback(() => {
                const newGrid = [];
                let validCount = 0;
                
                // 根據類型決定角落設定
                let activeCorners = {
                    tl: { w: 0, h: 0 },
                    tr: { w: 0, h: 0 },
                    bl: { w: 0, h: 0 },
                    br: { w: 0, h: 0 }
                };

                if (gridType === 'cross') {
                    activeCorners = { tl: uniformCorner, tr: uniformCorner, bl: uniformCorner, br: uniformCorner };
                } else if (gridType === 'gen-cross') {
                    activeCorners = corners;
                }

                for (let r = 0; r < rows; r++) {
                    const row = [];
                    for (let c = 0; c < cols; c++) {
                        let status = 'empty';
                        if (isVoid(r, c, rows, cols, activeCorners)) {
                            status = 'void';
                        } else {
                            validCount++;
                        }
                        row.push({ r, c, status });
                    }
                    newGrid.push(row);
                }

                setGrid(newGrid);
                setTotalValidCells(validCount);
                setRound(0);
                setInitialCount(0);
                setCurrentInfectedCount(0);
                setSimulationStatus('idle');
                setIsRunning(false);
            }, [rows, cols, gridType, uniformCorner, corners]);

            // 當參數改變時重新生成
            useEffect(() => {
                generateGrid();
            }, [generateGrid]);

            // --- 互動邏輯 ---

            const handleCellClick = (r, c) => {
                if (round > 0) return; // 模擬開始後不能修改
                if (grid[r][c].status === 'void') return;

                const newGrid = [...grid];
                // 複製 row 和 cell
                newGrid[r] = [...newGrid[r]];
                const cell = { ...newGrid[r][c] };

                if (cell.status === 'empty') {
                    cell.status = 'initial';
                    cell.roundInfected = 0;
                } else if (cell.status === 'initial') {
                    cell.status = 'empty';
                    cell.roundInfected = undefined;
                }

                newGrid[r][c] = cell;
                setGrid(newGrid);
                
                // 更新計數
                const initial = newGrid.flat().filter(cell => cell.status === 'initial').length;
                setInitialCount(initial);
                setCurrentInfectedCount(initial);
            };

            // --- 模擬邏輯 ---

            const getNeighbors = (r, c, currentGrid) => {
                const neighbors = [
                    { r: r - 1, c: c },
                    { r: r + 1, c: c },
                    { r: r, c: c - 1 },
                    { r: r, c: c + 1 },
                ];
                return neighbors.filter(n => 
                    n.r >= 0 && n.r < rows && 
                    n.c >= 0 && n.c < cols && 
                    currentGrid[n.r][n.c].status !== 'void'
                );
            };

            const stepSimulation = () => {
                if (simulationStatus === 'completed' || simulationStatus === 'stalled') return;

                setGrid(prevGrid => {
                    const newGrid = prevGrid.map(row => row.map(cell => ({ ...cell })));
                    let changed = false;
                    let nextInfectedCount = 0;

                    // 計算下一步
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const cell = prevGrid[r][c];
                            
                            if (cell.status === 'empty') {
                                const neighbors = getNeighbors(r, c, prevGrid);
                                const infectedNeighbors = neighbors.filter(n => 
                                    prevGrid[n.r][n.c].status === 'initial' || 
                                    prevGrid[n.r][n.c].status === 'infected'
                                ).length;

                                if (infectedNeighbors >= 2) {
                                    newGrid[r][c].status = 'infected';
                                    newGrid[r][c].roundInfected = round + 1;
                                    changed = true;
                                }
                            }
                        }
                    }

                    // 統計總感染數
                    nextInfectedCount = newGrid.flat().filter(c => c.status === 'initial' || c.status === 'infected').length;
                    setCurrentInfectedCount(nextInfectedCount);

                    // 判斷狀態
                    if (!changed) {
                        setIsRunning(false);
                        if (nextInfectedCount === totalValidCells) {
                            setSimulationStatus('completed');
                        } else {
                            setSimulationStatus('stalled');
                        }
                    } else {
                        if (nextInfectedCount === totalValidCells) {
                            setSimulationStatus('completed');
                            setIsRunning(false);
                        } else {
                            setSimulationStatus('running');
                        }
                        setRound(prev => prev + 1);
                    }

                    return newGrid;
                });
            };

            // --- 自動播放控制 ---
            useEffect(() => {
                if (isRunning) {
                    timerRef.current = setInterval(stepSimulation, 300); // 每 300ms 一步
                } else {
                    if (timerRef.current) clearInterval(timerRef.current);
                }
                return () => {
                    if (timerRef.current) clearInterval(timerRef.current);
                };
            }, [isRunning, grid, simulationStatus]);

            const resetSimulation = () => {
                setIsRunning(false);
                setRound(0);
                setSimulationStatus('idle');
                setGrid(prev => prev.map(row => row.map(cell => ({
                    ...cell,
                    status: cell.status === 'infected' ? 'empty' : cell.status,
                    roundInfected: cell.status === 'initial' ? 0 : undefined
                }))));
                setCurrentInfectedCount(initialCount);
            };

            const clearAll = () => {
                generateGrid();
            };

            // --- UI 渲染 ---
            return (
                <div className="min-h-screen bg-slate-50 p-4 md:p-8 font-sans text-slate-800">
                    <div className="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-6">
                        
                        {/* 標題與簡介 */}
                        <div className="lg:col-span-12 mb-2">
                            <h1 className="text-3xl font-bold text-slate-900 mb-2 flex items-center gap-2">
                                <IconGrid className="w-8 h-8 text-indigo-600" />
                                感染方塊模擬器 (Bootstrap Percolation)
                            </h1>
                            <p className="text-slate-600">
                                驗證數學科展理論：在網格中，若一個方塊有 2 個或更多鄰居被感染，則該方塊也會被感染。
                                <br/>
                                目標：尋找最少的初始感染方塊，使得整個網格最終都被感染。
                            </p>
                        </div>

                        {/* 左側：控制面板 */}
                        <div className="lg:col-span-4 space-y-6">
                        
                            {/* 1. 形狀與大小設定 */}
                            <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
                                <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                                    <span className="bg-indigo-100 text-indigo-700 w-6 h-6 flex items-center justify-center rounded-full text-sm">1</span>
                                    網格設定
                                </h2>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium text-slate-700 mb-1">網格類型</label>
                                        <div className="flex rounded-md shadow-sm" role="group">
                                            <button
                                                onClick={() => setGridType('rect')}
                                                className={`px-4 py-2 text-sm font-medium rounded-l-lg border flex-1 ${
                                                gridType === 'rect' ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white text-slate-700 border-slate-300 hover:bg-slate-50'
                                                }`}
                                            >
                                                長方形
                                            </button>
                                            <button
                                                onClick={() => setGridType('cross')}
                                                className={`px-4 py-2 text-sm font-medium border-t border-b border-r flex-1 ${
                                                gridType === 'cross' ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white text-slate-700 border-slate-300 hover:bg-slate-50'
                                                }`}
                                            >
                                                十字形
                                            </button>
                                            <button
                                                onClick={() => setGridType('gen-cross')}
                                                className={`px-4 py-2 text-sm font-medium rounded-r-lg border-t border-b border-r flex-1 ${
                                                gridType === 'gen-cross' ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white text-slate-700 border-slate-300 hover:bg-slate-50'
                                                }`}
                                            >
                                                廣義十字
                                            </button>
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm text-slate-600 mb-1">總高度 (Row)</label>
                                            <input type="number" min="3" max="20" value={rows} onChange={(e) => setRows(Math.max(3, Math.min(25, parseInt(e.target.value) || 0)))} 
                                                className="w-full px-3 py-2 border border-slate-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" />
                                        </div>
                                        <div>
                                            <label className="block text-sm text-slate-600 mb-1">總寬度 (Col)</label>
                                            <input type="number" min="3" max="20" value={cols} onChange={(e) => setCols(Math.max(3, Math.min(25, parseInt(e.target.value) || 0)))}
                                                className="w-full px-3 py-2 border border-slate-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" />
                                        </div>
                                    </div>

                                    {/* 十字形特有設定 */}
                                    {gridType === 'cross' && (
                                        <div className="p-3 bg-slate-50 rounded-lg border border-slate-200">
                                            <label className="block text-sm font-medium text-slate-700 mb-2">四角切除大小 (對稱)</label>
                                            <div className="grid grid-cols-2 gap-2">
                                                <input type="number" placeholder="W" value={uniformCorner.w} onChange={(e) => setUniformCorner({...uniformCorner, w: parseInt(e.target.value) || 0})}
                                                    className="w-full px-2 py-1 text-sm border rounded" />
                                                <input type="number" placeholder="H" value={uniformCorner.h} onChange={(e) => setUniformCorner({...uniformCorner, h: parseInt(e.target.value) || 0})}
                                                    className="w-full px-2 py-1 text-sm border rounded" />
                                            </div>
                                            <p className="text-xs text-slate-500 mt-1">四個角落將切除相同的寬與高。</p>
                                        </div>
                                    )}

                                    {/* 廣義十字形設定 */}
                                    {gridType === 'gen-cross' && (
                                        <div className="space-y-2">
                                            <label className="block text-sm font-medium text-slate-700">角落切除設定 (寬 x 高)</label>
                                            <div className="grid grid-cols-2 gap-2 p-2 bg-slate-100 rounded border border-slate-200 relative">
                                                {/* Visual representation of corners */}
                                                <div className="absolute inset-0 flex items-center justify-center opacity-10 pointer-events-none">
                                                    <IconPlus className="w-12 h-12" />
                                                </div>

                                                <div className="space-y-1">
                                                    <span className="text-xs text-slate-500">左上 (Top-Left)</span>
                                                    <div className="flex gap-1">
                                                        <input className="w-full text-xs p-1 border rounded" type="number" value={corners.tl.w} onChange={(e) => setCorners({...corners, tl: {...corners.tl, w: parseInt(e.target.value)||0}})} />
                                                        <span className="text-slate-400">x</span>
                                                        <input className="w-full text-xs p-1 border rounded" type="number" value={corners.tl.h} onChange={(e) => setCorners({...corners, tl: {...corners.tl, h: parseInt(e.target.value)||0}})} />
                                                    </div>
                                                </div>

                                                <div className="space-y-1 text-right">
                                                    <span className="text-xs text-slate-500">右上 (Top-Right)</span>
                                                    <div className="flex gap-1 justify-end">
                                                        <input className="w-full text-xs p-1 border rounded" type="number" value={corners.tr.w} onChange={(e) => setCorners({...corners, tr: {...corners.tr, w: parseInt(e.target.value)||0}})} />
                                                        <span className="text-slate-400">x</span>
                                                        <input className="w-full text-xs p-1 border rounded" type="number" value={corners.tr.h} onChange={(e) => setCorners({...corners, tr: {...corners.tr, h: parseInt(e.target.value)||0}})} />
                                                    </div>
                                                </div>

                                                <div className="space-y-1">
                                                    <span className="text-xs text-slate-500">左下 (Bot-Left)</span>
                                                    <div className="flex gap-1">
                                                        <input className="w-full text-xs p-1 border rounded" type="number" value={corners.bl.w} onChange={(e) => setCorners({...corners, bl: {...corners.bl, w: parseInt(e.target.value)||0}})} />
                                                        <span className="text-slate-400">x</span>
                                                        <input className="w-full text-xs p-1 border rounded" type="number" value={corners.bl.h} onChange={(e) => setCorners({...corners, bl: {...corners.bl, h: parseInt(e.target.value)||0}})} />
                                                    </div>
                                                </div>

                                                <div className="space-y-1 text-right">
                                                    <span className="text-xs text-slate-500">右下 (Bot-Right)</span>
                                                    <div className="flex gap-1 justify-end">
                                                        <input className="w-full text-xs p-1 border rounded" type="number" value={corners.br.w} onChange={(e) => setCorners({...corners, br: {...corners.br, w: parseInt(e.target.value)||0}})} />
                                                        <span className="text-slate-400">x</span>
                                                        <input className="w-full text-xs p-1 border rounded" type="number" value={corners.br.h} onChange={(e) => setCorners({...corners, br: {...corners.br, h: parseInt(e.target.value)||0}})} />
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* 2. 統計數據 */}
                            <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
                                <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
                                    <span className="bg-indigo-100 text-indigo-700 w-6 h-6 flex items-center justify-center rounded-full text-sm">2</span>
                                    實驗數據
                                </h2>
                                <div className="grid grid-cols-2 gap-4">
                                    <div className="bg-blue-50 p-3 rounded-lg border border-blue-100">
                                        <div className="text-xs text-blue-600 font-medium">初始感染格數</div>
                                        <div className="text-2xl font-bold text-blue-800">{initialCount}</div>
                                    </div>
                                    <div className="bg-orange-50 p-3 rounded-lg border border-orange-100">
                                        <div className="text-xs text-orange-600 font-medium">總感染格數</div>
                                        <div className="text-2xl font-bold text-orange-800">{currentInfectedCount} <span className="text-sm text-orange-400 font-normal">/ {totalValidCells}</span></div>
                                    </div>
                                    <div className="bg-slate-100 p-3 rounded-lg border border-slate-200">
                                        <div className="text-xs text-slate-600 font-medium">經過回合</div>
                                        <div className="text-2xl font-bold text-slate-800">{round}</div>
                                    </div>
                                    <div className={`p-3 rounded-lg border flex flex-col justify-center ${
                                        simulationStatus === 'completed' ? 'bg-green-100 border-green-200' : 
                                        simulationStatus === 'stalled' ? 'bg-red-100 border-red-200' : 'bg-gray-50 border-gray-200'
                                    }`}>
                                        <div className="text-xs font-medium text-slate-500">狀態</div>
                                        <div className={`font-bold ${
                                            simulationStatus === 'completed' ? 'text-green-700' : 
                                            simulationStatus === 'stalled' ? 'text-red-700' : 'text-slate-700'
                                        }`}>
                                        {simulationStatus === 'idle' && '準備就緒'}
                                        {simulationStatus === 'running' && '擴散中...'}
                                        {simulationStatus === 'completed' && '完全感染!'}
                                        {simulationStatus === 'stalled' && '擴散停止'}
                                        </div>
                                    </div>
                                </div>
                            </div>

                            {/* 3. 操作說明 */}
                            <div className="bg-indigo-50 p-4 rounded-xl border border-indigo-100 text-sm text-indigo-800">
                                <div className="font-semibold flex items-center gap-2 mb-2">
                                    <IconInfo className="w-4 h-4" /> 操作指南
                                </div>
                                <ul className="list-disc pl-4 space-y-1">
                                    <li>點擊網格中的白色格子，設置為<b>初始感染</b> (深藍色)。</li>
                                    <li>設定完成後，使用下方的播放鍵開始模擬。</li>
                                    <li><b>規則</b>：當一個格子有 2 個或以上的鄰居被感染，它將在下一回合變為感染狀態。</li>
                                </ul>
                            </div>
                        </div>

                        {/* 右側：網格顯示與模擬控制 */}
                        <div className="lg:col-span-8 flex flex-col h-full space-y-4">
                        
                            {/* 網格容器 */}
                            <div className="flex-1 bg-white p-4 md:p-8 rounded-xl shadow-sm border border-slate-200 flex items-center justify-center overflow-auto min-h-[400px] relative">
                                
                                {/* Grid 渲染 */}
                                <div 
                                    style={{ 
                                        display: 'grid', 
                                        gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))`,
                                        gap: '2px',
                                        width: '100%',
                                        maxWidth: `${cols * 40}px`,
                                        aspectRatio: `${cols}/${rows}`
                                    }}
                                >
                                    {grid.map((row, rIndex) => (
                                        row.map((cell, cIndex) => {
                                            if (cell.status === 'void') {
                                                return <div key={`${rIndex}-${cIndex}`} className="bg-transparent" />;
                                            }

                                            let bgColor = 'bg-white hover:bg-slate-100'; // empty
                                            let borderColor = 'border-slate-300';
                                            
                                            if (cell.status === 'initial') {
                                                bgColor = 'bg-indigo-600 hover:bg-indigo-700'; // initial
                                                borderColor = 'border-indigo-600';
                                            } else if (cell.status === 'infected') {
                                                bgColor = 'bg-orange-500 animate-pulse-once'; // infected
                                                borderColor = 'border-orange-500';
                                            }

                                            return (
                                                <div
                                                    key={`${rIndex}-${cIndex}`}
                                                    onClick={() => handleCellClick(rIndex, cIndex)}
                                                    className={`
                                                        aspect-square border rounded-sm cursor-pointer transition-all duration-200
                                                        flex items-center justify-center relative
                                                        ${bgColor} ${borderColor}
                                                    `}
                                                    title={`(${rIndex}, ${cIndex})`}
                                                >
                                                    {/* 顯示被感染的回合數 (可選) */}
                                                    {cell.status === 'infected' && (
                                                        <span className="text-[10px] text-white font-bold opacity-80">
                                                            {cell.roundInfected}
                                                        </span>
                                                    )}
                                                    {cell.status === 'initial' && (
                                                        <div className="w-2 h-2 bg-white rounded-full opacity-50" />
                                                    )}
                                                </div>
                                            );
                                        })
                                    ))}
                                </div>

                                {/* 提示遮罩：模擬進行中不能編輯 */}
                                {(round > 0 && simulationStatus !== 'idle') && (
                                    <div className="absolute top-4 right-4 bg-black/70 text-white text-xs px-3 py-1 rounded-full pointer-events-none">
                                        模擬模式 (唯讀)
                                    </div>
                                )}
                            </div>

                            {/* 底部控制列 */}
                            <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-200 flex flex-wrap items-center justify-between gap-4">
                                
                                <div className="flex items-center gap-2">
                                    <button 
                                        onClick={clearAll}
                                        className="flex items-center gap-2 px-4 py-2 text-slate-600 bg-slate-100 hover:bg-slate-200 rounded-lg transition-colors"
                                    >
                                        <IconMousePointer2 className="w-4 h-4" />
                                        清空重選
                                    </button>
                                    <button 
                                        onClick={resetSimulation}
                                        disabled={round === 0}
                                        className={`flex items-center gap-2 px-4 py-2 rounded-lg transition-colors border ${
                                        round > 0 
                                            ? 'text-slate-700 border-slate-300 hover:bg-slate-50' 
                                            : 'text-slate-300 border-slate-200 cursor-not-allowed'
                                        }`}
                                    >
                                        <IconRotateCcw className="w-4 h-4" />
                                        重置狀態
                                    </button>
                                </div>

                                <div className="flex items-center gap-2">
                                    <button 
                                        onClick={stepSimulation}
                                        disabled={simulationStatus === 'completed' || simulationStatus === 'stalled' || isRunning}
                                        className="flex items-center gap-2 px-4 py-2 text-indigo-700 bg-indigo-50 border border-indigo-200 hover:bg-indigo-100 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        <IconStepForward className="w-4 h-4" />
                                        單步執行
                                    </button>
                                    
                                    {!isRunning ? (
                                        <button 
                                            onClick={() => setIsRunning(true)}
                                            disabled={simulationStatus === 'completed' || simulationStatus === 'stalled'}
                                            className="flex items-center gap-2 px-6 py-2 text-white bg-indigo-600 hover:bg-indigo-700 rounded-lg shadow-sm hover:shadow transition-all disabled:bg-slate-300 disabled:cursor-not-allowed"
                                        >
                                            <IconPlay className="w-4 h-4 fill-current" />
                                            自動模擬
                                        </button>
                                    ) : (
                                        <button 
                                            onClick={() => setIsRunning(false)}
                                            className="flex items-center gap-2 px-6 py-2 text-white bg-amber-500 hover:bg-amber-600 rounded-lg shadow-sm hover:shadow transition-all"
                                        >
                                            <IconPause className="w-4 h-4 fill-current" />
                                            暫停
                                        </button>
                                    )}
                                </div>

                            </div>
                        </div>

                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>